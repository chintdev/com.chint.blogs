<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>事件机制</title>
      <link href="/2021/11/02/10.29EventLoop/"/>
      <url>/2021/11/02/10.29EventLoop/</url>
      
        <content type="html"><![CDATA[<h2 id="仅代表个人理解"><a href="#仅代表个人理解" class="headerlink" title="仅代表个人理解"></a>仅代表个人理解</h2><ul><li>promise、async、setTimeout 执行顺序</li><li>理解Event Loop（事件循环）</li></ul><details><summary>Event Loop（事件循环）</summary><blockquote> <details> <summary>需要了解的一些点</summary><ul><li><p>首先是js运行机制是什么？  </p><ul><li>JavaScript语言是单线程的，同一个时间只能做一件事；</li><li>遵循事件循环机制，当JS解析执行时，会被引擎分为两类任务，同步任务（synchronous） 和 异步任务（asynchronous）。对于同步任务来说，会被推到执行栈按顺序去执行这些任务。对于异步任务来说，当其可以被执行时，会被放到一个 任务队列（task queue） 里等待JS引擎去执行。当执行栈中的所有同步任务完成后，JS引擎才会去任务队列里查看是否有任务存在，并将任务放到执行栈中去执行，执行完了又会去任务队列里查看是否有已经可以执行的任务。这种循环检查的机制，就叫做事件循环(Event Loop)。对于任务队列，其实是有更细的分类。其被分为 微任务（microtask）队列 &amp; 宏任务（macrotask）队列。</li><li><strong>总结：同步任务是同步任务，异步任务分（微任务、宏任务）</strong></li></ul></li><li><p>任务队列是什么？</p><ul><li><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p></li><li><p>所有任务可以分成两种，一种是<strong>同步任务（synchronous）</strong>，另一种是<strong>异步任务（asynchronous）</strong>。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p></li><li><p>异步任务可以分为（微任务、宏任务），微任务优先级高于宏任务。</p></li><li><p>异步执行的运行机制如下：</p><blockquote><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p></blockquote><blockquote><p>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p></blockquote><blockquote><p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p></blockquote><blockquote><p>（4）主线程不断重复上面的第三步。</p></blockquote></li></ul></li></ul><p><img src="https://pic1.zhimg.com/80/v2-59a1cbab9a259817f728849d60ede6ac_720w.jpg" alt=" &quot;eventloop&quot; "></p><ul><li><strong>宏任务</strong>包括：script(整体代码)，I/O， setTimeout，setInterval，requestAnimationFrame，setImmediate。其中setImmediate只存在于Node中，requestAnimationFrame只存在于浏览器中。</li><li><strong>微任务</strong>包括：Promise，Object.observe(已废弃)，MutationObserver(html5新特性)，process.nextTick。其中process.nextTick只存在于Node中，MutationObserver只存在于浏览器中。</li></ul><p><img src="https://img-blog.csdnimg.cn/2020120520201083.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTY3OTg1,size_16,color_FFFFFF,t_70" alt="图片"></p><h3 id="完整关系"><a href="#完整关系" class="headerlink" title="完整关系"></a>完整关系</h3><p><img src="image.png" alt="图片"></p></details></blockquote></details>  <details>   <summary>问题？</summary>   <figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------------</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">}, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  resolve();</span><br><span class="line">}).then(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">});</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">time</span>) </span>{</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  }).then(<span class="function">()=&gt;</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">15</span>)</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line">  (<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">12</span>)</span><br><span class="line">  <span class="keyword">await</span> delay(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">14</span>);</span><br><span class="line">})();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">// 1 3 12 6 5 4 14 2 15</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></details><ul><li>了解Promise</li></ul><blockquote><p>Promise是异步编程的一种解决方案，其实是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法。</p></blockquote><ul><li>Promise运行顺序总结<ul><li>promise的构造函数是同步执行，promise.then中的函数是异步执行。</li><li>构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用。promise状态一旦改变则不能再变。</li><li>promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。</li><li>如果在一个then（）中没有返回一个新的promise，则 return 什么下一个then就接受什么，如果then中没有return，则默认return的是 undefined.</li><li>then()的嵌套会先将内部的then()执行完毕再继续执行外部的then();</li><li>catch和then的连用，如果每一步都有可能出现错误，那么就可能出现catch后面接上then的情况。如果在catch中也抛出了错误，则后面的then的第一个函数不会执行，因为返回的 promise状态已经为rejected了</li></ul></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>浏览器和Node环境下，microtask 任务队列的执行时机不同：Node 端，microtask 在事件循环的各个阶段之间执行；浏览器端，microtask 在事件循环的 macrotask 执行完之后执行；</strong></p>]]></content>
      
      
      <categories>
          
          <category> EventLoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> promise </tag>
            
            <tag> async </tag>
            
            <tag> setTimeout </tag>
            
            <tag> synchronous </tag>
            
            <tag> asynchronous </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm机制</title>
      <link href="/2021/11/02/npm%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/11/02/npm%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-npm-install-机制"><a href="#1-npm-install-机制" class="headerlink" title="1. npm install 机制"></a>1. npm install 机制</h2><p>假设项目App中有如下三个依赖：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: {</span><br><span class="line">    <span class="attr">A</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">B</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">C</span>: <span class="string">"1.0.0"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>A、B、C三个模块又有如下依赖：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A@<span class="number">1.0</span><span class="number">.0</span> -&gt; D@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">B@<span class="number">1.0</span><span class="number">.0</span> -&gt; D@<span class="number">2.0</span><span class="number">.0</span></span><br><span class="line">C@<span class="number">1.0</span><span class="number">.0</span> -&gt; D@<span class="number">2.0</span><span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure><h3 id="npm-2-x-时代-嵌套安装"><a href="#npm-2-x-时代-嵌套安装" class="headerlink" title="npm 2.x 时代 嵌套安装"></a>npm 2.x 时代 嵌套安装</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules</span><br><span class="line">│&nbsp;&nbsp; ├── A@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── node_modules</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── D@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; ├── B@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── node_modules</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── D@<span class="number">2.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; └── C@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── node_modules</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── D@<span class="number">2.0</span><span class="number">.0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>优点：</p><ul><li>层级结构明显</li><li>简单的实现了多版本兼容</li><li>保证了对依赖包无论是安装还是删除都会有统一的行为和结构</li></ul><p>缺点：</p><ul><li>可能造成相同模块大量冗余问题</li><li>可能造成目录结构嵌套比较深的问题<h3 id="npm-3-x开始-扁平安装"><a href="#npm-3-x开始-扁平安装" class="headerlink" title="npm 3.x开始 -扁平安装"></a>npm 3.x开始 -扁平安装</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules</span><br><span class="line">│&nbsp;&nbsp; ├── A@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── node_modules</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── D@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; ├── B@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; ├── C@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; └── D@<span class="number">2.0</span><span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure>可以看到，<a href="mailto:D@2.0.0">D@2.0.0</a>模块被安装在一级node_modules中，而<a href="mailto:D@1.0.0">D@1.0.0</a>仍被安装在<a href="mailto:A@1.0.0">A@1.0.0</a>中。所以可以得出结论，<strong>在执行npm install安装时，如果遇到相同依赖的包，会优先将高版本（大版本）的包放在一级node_modules中，低版本的包则会按照npm 2.x的方式依次挂在依赖包的node_modules中。</strong></li></ul><p>再在项目中安装模块<a href="mailto:E@1.0.0">E@1.0.0</a>（依赖于模块<a href="mailto:D@1.0.0">D@1.0.0</a>），目录结构变为：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules</span><br><span class="line">│&nbsp;&nbsp; ├── A@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── node_modules</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── D@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; ├── B@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; ├── C@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; ├── D@<span class="number">2.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; ├── E@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── node_modules</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── D@<span class="number">1.0</span><span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure><p>再在项目中安装模块<a href="mailto:F@1.0.0">F@1.0.0</a>（依赖于模块<a href="mailto:D@2.0.0">D@2.0.0</a>），目录结构变为：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules</span><br><span class="line">│&nbsp;&nbsp; ├── A@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── node_modules</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── D@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; ├── B@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; ├── C@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; ├── D@<span class="number">2.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; ├── E@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── node_modules</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── D@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│&nbsp;&nbsp; └── F@<span class="number">1.0</span><span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，只会安装F模块。所以可以得出结论，<strong>在一级node_moudles中已经存在依赖包的情况下，新安装的依赖包如果不存在版本冲突，则会忽略安装</strong>。<br>从以上示例可以看出，npm 3.x并没有完美的解决npm 2.x中的问题，甚至还会退化到npm 2.x的行为。</p><h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><p>从npm 5.x开始，执行npm install时会自动生成一个<a href="https://link.juejin.cn/?target=https://docs.npmjs.com/files/package-lock.json">package-lock.json</a> 文件。<br>​</p><p>npm为了让开发者<strong>在安全的前提下使用最新的依赖包</strong>，在package.json中通常做了锁定大版本的操作，这样在每次npm install的时候都会拉取依赖包大版本下的最新的版本。这种机制最大的一个缺点就是当有依赖包有小版本更新时，可能会出现协同开发者的依赖包不一致的问题。</p><p>package-lock.json的详细描述主要由version、resolved、integrity、dev、requires、dependencies这几个字段构成</p><ul><li>version：包唯一的版本号</li><li>resolved：安装源</li><li>integrity：表明包完整性的hash值（验证包是否已失效）</li><li>dev：如果为true，则此依赖关系仅是顶级模块的开发依赖关系或者是一个的传递依赖关系</li><li>requires：依赖包所需要的所有依赖项，对应依赖包package.json里dependencies中的依赖项</li><li>dependencies：依赖包node_modules中依赖的包，与顶层的dependencies一样的结构<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: {</span><br><span class="line">  <span class="string">"sass-loader"</span>: {</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"7.1.0"</span>,</span><br><span class="line">    <span class="string">"resolved"</span>: <span class="string">"http://registry.npm.taobao.org/sass-loader/download/sass-loader-7.1.0.tgz"</span>,</span><br><span class="line">    <span class="string">"integrity"</span>: <span class="string">"sha1-Fv1ROMuLQkv4p1lSihly1yqtBp0="</span>,</span><br><span class="line">    <span class="string">"dev"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"requires"</span>: {</span><br><span class="line">      <span class="string">"clone-deep"</span>: <span class="string">"^2.0.1"</span>,</span><br><span class="line">      <span class="string">"loader-utils"</span>: <span class="string">"^1.0.1"</span>,</span><br><span class="line">      <span class="string">"lodash.tail"</span>: <span class="string">"^4.1.1"</span>,</span><br><span class="line">      <span class="string">"neo-async"</span>: <span class="string">"^2.5.0"</span>,</span><br><span class="line">      <span class="string">"pify"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">      <span class="string">"semver"</span>: <span class="string">"^5.5.0"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="string">"dependencies"</span>: {</span><br><span class="line">      <span class="string">"pify"</span>: {</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"3.0.0"</span>,</span><br><span class="line">        <span class="string">"resolved"</span>: <span class="string">"http://registry.npm.taobao.org/pify/download/pify-3.0.0.tgz"</span>,</span><br><span class="line">        <span class="string">"integrity"</span>: <span class="string">"sha1-5aSs0sEB/fPZpNB/DbxNtJ3SgXY="</span>,</span><br><span class="line">        <span class="string">"dev"</span>: <span class="literal">true</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>package-lock.json文件和node_modules目录结构是一一对应的，即项目目录下存在package-lock.json可以让每次安装生成的依赖目录结构保持相同。<br>在开发一个应用时，建议把package-lock.json文件提交到代码版本仓库，从而让你的团队成员、运维部署人员或CI系统可以在执行npm install时安装的依赖版本都是一致的。<br>但是在开发一个库时，则不应把package-lock.json文件发布到仓库中。实际上，npm也默认不会把package-lock.json文件发布出去。之所以这么做，是因为库项目一般是被其他项目依赖的，在不写死的情况下，就可以复用主项目已经加载过的包，而一旦库依赖的是精确的版本号那么可能会造成包的冗余。<br>​</li></ul><h2 id="2-npm-中的依赖包"><a href="#2-npm-中的依赖包" class="headerlink" title="2. npm 中的依赖包"></a>2. npm 中的依赖包</h2><h3 id="依赖包分类"><a href="#依赖包分类" class="headerlink" title="依赖包分类"></a>依赖包分类</h3><ul><li><strong>dependencies - 业务依赖</strong></li><li><strong>devDependencies - 开发依赖</strong></li><li><strong>peerDependencies - 同伴依赖</strong></li><li><strong>bundledDependencies / bundleDependencies - 打包依赖</strong></li><li><strong>optionalDependencies - 可选依赖</strong></li></ul><p>作为npm的使用者，我们常用的依赖是dependencies和devDependencies，剩下三种依赖则是作为包的发布者才会使用到的字段。</p><h4 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a><strong>dependencies</strong></h4><p>这种依赖在项目最终上线或者发布npm包时所需要，即其中的依赖项应该属于线上代码的一部分。比如框架vue，第三方的组件库element-ui等，这些依赖包都是必须装在这个选项里供生产环境使用。<br>通过命令npm install/i packageName -S/–save把包装在此依赖项里。如果没有指定版本，直接写一个包的名字，则安装当前npm仓库中这个包的最新版本。如果要指定版本的，可以把版本号写在包名后面，比如npm i <a href="mailto:vue@3.0.1">vue@3.0.1</a> -S。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install/i packageName -S/--save</span><br><span class="line"></span><br><span class="line">// 从npm 5.x开始，可以不用手动添加-S/--save指令，直接执行npm i packageName把依赖包添加到dependencies中去。</span><br></pre></td></tr></tbody></table></figure><p>​</p><h4 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a><strong>devDependencies</strong></h4><p>这种依赖只在项目开发时所需要，即其中的依赖项不应该属于线上代码的一部分。比如构建工具webpack、gulp，预处理器babel-loader、scss-loader，测试工具e2e、chai等，这些都是辅助开发的工具包，无须在生产环境使用。</p><figure class="highlight erlang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install/i -D/--save-dev</span><br><span class="line">npm i --production // 线上机器（或者QA环境）上使用</span><br><span class="line"></span><br><span class="line">提示：千万别以为只有在dependencies中的模块才会被一起打包，而在devDependencies中的不会！模块能否被打包，取决于项目里是否被引入了该模块！</span><br></pre></td></tr></tbody></table></figure><p>在业务项目中dependencies和devDependencies没有什么本质区别，只是单纯的一个规范作用，在执行npm i时两个依赖下的模块都会被下载；而在发布npm包的时候，包中的dependencies依赖项在安装该包的时候会被一起下载，devDependencies依赖项则不会。</p><h4 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a><strong>peerDependencies</strong></h4><p>这种依赖的作用是提示宿主环境去安装插件在peerDependencies中所指定依赖的包，然后插件所依赖的包永远都是宿主环境统一安装的npm包，最终解决插件与所依赖包不一致的问题。<br>这句话听起来可能有点拗口，举个例子来给大家说明下。<a href="mailto:element-ui@2.6.3">element-ui@2.6.3</a>只是提供一套基于vue的ui组件库，但它要求宿主环境需要安装指定的vue版本，所以你可以看到element项目中的package.json中具有一项配置：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"peerDependencies"</span>: {</span><br><span class="line">    <span class="string">"vue"</span>: <span class="string">"^2.5.16"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>它要求宿主环境安装3.0.0 &gt; vue@ &gt;= 2.5.16的版本，也就是element-ui的运行依赖宿主环境提供的该版本范围的vue依赖包<br>​</p><p>总结：大白话：如果你安装我，那么你最好也要按照我的要求安装A、B和C。</p><h4 id="bundledDependencies"><a href="#bundledDependencies" class="headerlink" title="**bundledDependencies **"></a>**bundledDependencies **</h4><p>这种依赖跟npm pack打包命令有关。假设package.json中有如下配置：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"font-end"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: {</span><br><span class="line">    <span class="string">"fe1"</span>: <span class="string">"^0.3.2"</span>,</span><br><span class="line">    ...</span><br><span class="line">  },</span><br><span class="line">  <span class="string">"devDependencies"</span>: {</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"fe2"</span>: <span class="string">"^1.0.0"</span></span><br><span class="line">  },</span><br><span class="line">  <span class="string">"bundledDependencies"</span>: [</span><br><span class="line">    <span class="string">"fe1"</span>,</span><br><span class="line">    <span class="string">"fe2"</span></span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行打包命令npm pack，会生成front-end-1.0.0.tgz压缩包，并且该压缩包中包含fe1和fe2两个安装包，这样使用者执行npm install front-end-1.0.0.tgz也会安装这两个依赖。<br>tips: 在bundledDependencies中指定的依赖包，必须先在dependencies和devDependencies声明过，否则打包会报错。</p><h4 id="optionalDependencies"><a href="#optionalDependencies" class="headerlink" title="optionalDependencies"></a><strong>optionalDependencies</strong></h4><p>这种依赖中的依赖项即使安装失败了，也不影响整个安装的过程。需要注意的是，如果一个依赖同时出现在dependencies和optionalDependencies中，那么optionalDependencies会获得更高的优先级，可能造成一些预期之外的效果，所以尽量要避免这种情况发生。<br>​</p><p>tips:  在实际项目中，如果某个包已经失效，我们通常会寻找它的替代者，或者换一个实现方案。不确定的依赖会增加代码判断和测试难度，所以这个依赖项还是尽量不要使用。</p><h3 id="依赖包版本号"><a href="#依赖包版本号" class="headerlink" title="依赖包版本号"></a>依赖包版本号</h3><p>npm采用了semver规范作为依赖版本管理方案。<br>​</p><p>一个npm依赖包的版本格式一般为：<strong>主版本号.次版本号.修订号</strong>（x.y.z），每个号的含义是：</p><ul><li><strong>主版本号</strong>（也叫大版本，major version）</li></ul><p>大版本的改动很可能是一次颠覆性的改动，也就意味着可能存在与低版本不兼容的API或者用法，（比如 vue 2 -&gt; 3)。</p><ul><li><strong>次版本号</strong>（也叫小版本，minor version）</li></ul><p>小版本的改动应当兼容同一个大版本内的API和用法，因此应该让开发者无感。所以我们通常只说大版本号，很少会精确到小版本号。<br>tips: 如果大版本号是 0 的话，表示软件处于开发初始阶段，一切都可能随时被改变，可能每个小版本之间也会存在不兼容性。所以在选择依赖时，尽量避开大版本号是 0 的包。</p><ul><li><strong>修订号</strong>（也叫补丁，patch）一般用于修复bug或者很细微的变更，也需要保持向前兼容。</li></ul><p>常见的几个版本格式如下：</p><ul><li><strong>“1.2.3”</strong></li></ul><p>表示精确版本号。任何其他版本号都不匹配。在一些比较重要的线上项目中，建议使用这种方式锁定版本。</p><ul><li><strong>“^1.2.3”</strong></li></ul><p>表示兼容补丁和小版本更新的版本号。官方的定义是“能够兼容除了最左侧的非 <strong>0</strong> 版本号之外的其他变化。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"^1.2.3"</span> 等价于 <span class="string">"&gt;= 1.2.3 &lt; 2.0.0"</span>。即只要最左侧的 <span class="string">"1"</span> 不变，其他都可以改变。所以 <span class="string">"1.2.4"</span>, <span class="string">"1.3.0"</span> 都可以兼容。</span><br><span class="line"></span><br><span class="line"><span class="string">"^0.2.3"</span> 等价于 <span class="string">"&gt;= 0.2.3 &lt; 0.3.0"</span>。因为最左侧的是 <span class="string">"0"</span>，那么只要第二位 <span class="string">"2"</span> 不变，其他的都兼容，比如 <span class="string">"0.2.4"</span> 和 <span class="string">"0.2.99"</span>。</span><br><span class="line"></span><br><span class="line"><span class="string">"^0.0.3"</span> 等价于 <span class="string">"&gt;= 0.0.3 &lt; 0.0.4"</span>。大版本号和小版本号都为 <span class="string">"0"</span> ，所以也就等价于精确的 <span class="string">"0.0.3"</span>。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>“~1.2.3”</strong></li></ul><p>表示只兼容补丁更新的版本号。关于 ~ 的定义分为两部分：如果列出了小版本号（第二位），则只兼容补丁（第三位）的修改；如果没有列出小版本号，则兼容第二和第三位的修改。我们分两种情况理解一下这个定义：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"~1.2.3"</span> 列出了小版本号 <span class="string">"2"</span>，因此只兼容第三位的修改，等价于 <span class="string">"&gt;= 1.2.3 &lt; 1.3.0"</span>。</span><br><span class="line"></span><br><span class="line"><span class="string">"~1.2"</span> 也列出了小版本号 <span class="string">"2"</span>，因此和上面一样兼容第三位的修改，等价于 <span class="string">"&gt;= 1.2.0 &lt; 1.3.0"</span>。</span><br><span class="line"></span><br><span class="line"><span class="string">"~1"</span> 没有列出小版本号，可以兼容第二第三位的修改，因此等价于 <span class="string">"&gt;= 1.0.0 &lt; 2.0.0"</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>“1.x” 、”1.X”、1.<em>“、”1”、”</em>“</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"*"</span> 、<span class="string">"x"</span> 或者 （空） 表示可以匹配任何版本。</span><br><span class="line"></span><br><span class="line"><span class="string">"1.x"</span>, <span class="string">"1.*"</span> 和 <span class="string">"1"</span> 表示匹配主版本号为 <span class="string">"1"</span> 的所有版本，因此等价于 <span class="string">"&gt;= 1.0.0 &lt; 2.0.0"</span>。</span><br><span class="line"></span><br><span class="line"><span class="string">"1.2.x"</span>, <span class="string">"1.2.*"</span> 和 <span class="string">"1.2"</span> 表示匹配版本号以 <span class="string">"1.2"</span> 开头的所有版本，因此等价于 <span class="string">"&gt;= 1.2.0 &lt; 1.3.0"</span>。</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>“1.2.3-alpha.1”、”1.2.3-beta.1”、”1.2.3-rc.1”</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alpha(α)：预览版，或者叫内部测试版；一般不向外部发布，会有很多bug；一般只有测试人员使用。</span><br><span class="line"></span><br><span class="line">beta(β)：测试版，或者叫公开测试版；这个阶段的版本会一直加入新的功能；在alpha版之后推出。</span><br><span class="line"></span><br><span class="line">rc(release candidate)：最终测试版本；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"~1.2.4-alpha.1"</span> 表示 <span class="string">"&gt;=1.2.4-alpha.1 &lt; 1.3.0"</span>。这样 <span class="string">"1.2.5"</span>, <span class="string">"1.2.4-alpha.2"</span> 都符合条件，而 <span class="string">"1.2.5-alpha.1"</span>, <span class="string">"1.3.0"</span> 不符合。</span><br><span class="line"></span><br><span class="line"><span class="string">"^1.2.4-alpha.1"</span> 表示 <span class="string">"&gt;=1.2.4-alpha.1 &lt; 2.0.0"</span>。这样 <span class="string">"1.2.5"</span>, <span class="string">"1.2.4-alpha.2"</span>, <span class="string">"1.3.0"</span> 都符合条件，而 <span class="string">"1.2.5-alpha.1"</span>, <span class="string">"2.0.0"</span> 不符合。</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;1.2.4-alpha.1"表示接受 "1.2.4-alpha" 版本下所有大于 1 的预发布版本。因此 "1.2.4-alpha.7" 是符合要求的，但 "1.2.4-beta.1" 和 "1.2.5-alpha.2" 都不符合。此外如果是正式版本（不带预发布关键词），只要版本号符合要求即可，不检查预发布版本号，例如 "1.2.5", "1.3.0" 都是认可的。</span></span><br></pre></td></tr></tbody></table></figure><p>以包开发者的角度来考虑这个问题：假设当前线上版本是 “1.2.3”，如果我作了一些改动需要发布版本 “1.2.4”，但我不想直接上线（因为使用 “~1.2.3” 或者 “^1.2.3” 的用户都会直接静默更新），这就需要使用预发布功能。因此我可能会发布 “1.2.4-alpha.1” 或者 “1.2.4-beta.1” 等等。</p><h3 id="依赖包版本管理"><a href="#依赖包版本管理" class="headerlink" title="依赖包版本管理"></a>依赖包版本管理</h3></li></ul><ol><li><p>在大版本相同的前提下，如果一个模块在package.json中的小版本要<strong>大于</strong>package-lock.json中的小版本，则在执行npm install时，会将该模块更新到大版本下的最新的版本，并将版本号更新至package-lock.json。如果<strong>小于</strong>，则被package-lock.json中的版本锁定。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package-lock.json 中原版本</span></span><br><span class="line"><span class="string">"clipboard"</span>: {</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.5.10"</span>, </span><br><span class="line">},</span><br><span class="line"><span class="string">"vue"</span>: {</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"2.6.10"</span>,</span><br><span class="line">}</span><br><span class="line"><span class="comment">// package.json 中修改版本</span></span><br><span class="line"><span class="string">"dependencies"</span>: {</span><br><span class="line">  <span class="string">"clipboard"</span>: <span class="string">"^1.5.12"</span>,</span><br><span class="line">  <span class="string">"vue"</span>: <span class="string">"^2.5.6"</span></span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行完 npm install 后，package-lock.json 中</span></span><br><span class="line"><span class="string">"clipboard"</span>: {</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.7.1"</span>, <span class="comment">// 更新到大版本下的最新版本</span></span><br><span class="line">},</span><br><span class="line"><span class="string">"vue"</span>: {</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"2.6.10"</span>, <span class="comment">// 版本没发生改变</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果一个模块在package.json和package-lock.json中的大版本不相同，则在执行npm install时，都将根据package.json中大版本下的最新版本进行更新，并将版本号更新至package-lock.json。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package-lock.json 中原版本</span></span><br><span class="line"><span class="string">"clipboard"</span>: {</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"2.0.4"</span>,</span><br><span class="line">}</span><br><span class="line"><span class="comment">// package.json 中修改版本</span></span><br><span class="line"><span class="string">"dependencies"</span>: {</span><br><span class="line">  <span class="string">"clipboard"</span>: <span class="string">"^1.6.1"</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行完npm install后，package-lock.json 中</span></span><br><span class="line"><span class="string">"clipboard"</span>: {</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.7.1"</span>, <span class="comment">// 更新到大版本下的最新版本</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果一个模块在package.json中有记录，而在package-lock.json中无记录，执行npm install后，则会在package-lock.json生成该模块的详细记录。同理，一个模块在package.json中无记录，而在package-lock.json中有记录，执行npm install后，则会在package-lock.json删除该模块的详细记录。</p></li></ol><h2 id="3-npm-scripts-脚本"><a href="#3-npm-scripts-脚本" class="headerlink" title="3. npm scripts 脚本"></a>3. npm scripts 脚本</h2><p>package.json中的 <a href="https://link.juejin.cn/?target=https://docs.npmjs.com/misc/scripts">scripts</a> 字段可以用来自定义脚本命令，它的每一个属性，对应一段脚本。以vue-cli3为例：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: {</span><br><span class="line">  <span class="string">"serve"</span>: <span class="string">"vue-cli-service serve"</span>,</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就可以通过npm run serve脚本代替vue-cli-service serve脚本来启动项目，而无需每次敲一遍这么冗长的脚本。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="package-json-中的-bin-字段"><a href="#package-json-中的-bin-字段" class="headerlink" title="package.json 中的 bin 字段"></a>package.json 中的 bin 字段</h4><p>package.json中的字段 <a href="https://link.juejin.cn/?target=https://docs.npmjs.com/files/package.json.html%23bin">bin</a> 表示的是一个<strong>可执行文件到指定文件源的映射</strong>。通过npm bin指令显示当前项目的bin目录的路径。例如在@vue/cli的package.json中：<br>例如:在chj-ip-tool的package.json中：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12582850/1634778717199-d5160d94-06bf-4a78-bc8b-cee18b0967e8.png#clientId=ubcbcb43a-f3df-4&amp;from=paste&amp;height=75&amp;id=u78df9db5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=75&amp;originWidth=259&amp;originalType=binary&amp;ratio=1&amp;size=2649&amp;status=done&amp;style=none&amp;taskId=u3ca378d9-3c35-4301-a6b8-c398725a4a1&amp;width=259" alt="image.png"><br>全局安装:<br>如果全局安装chj-ip-tool的话， npm会在全局可执行bin文件安装目录            C:\Users\Administrator\AppData\Roaming\npm下创建一个指向C:\Users\Administrator\AppData\Roaming\npm\node_modules\chj-ip-tool\bin\cli.js文件的名为my-ip的软链接，这样就可以直接在终端输入my-ip来执行相关命令。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12582850/1629032050100-a436e440-cf65-4a1b-a1e8-88eae7c7d5d8.png#clientId=ue2a260f2-efff-4&amp;from=paste&amp;height=40&amp;id=u73dbfd80&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=62&amp;originWidth=907&amp;originalType=binary&amp;ratio=1&amp;size=29245&amp;status=done&amp;style=none&amp;taskId=u7f4aa3cd-80fb-439e-80b7-18c11e136b2&amp;width=588.4977722167969" alt="image.png"><br>局部安装:<br>如果局部安装chj-ip-tool的话，npm则会在本地项目./node_modules/.bin目录下创建一个指向./node_moudles/haijia-tool/bin/cli.js名为my-ip的软链接，这个时候如果想要执行my-ip命令有三种方式：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 直接输入.\node_modules\.bin\my-ip来执行。 </span><br><span class="line"><span class="number">2.</span> 使用npx vue命令来执行（npx 的作用就是为了方便调用项目内部安装的模块） </span><br><span class="line"><span class="number">3.</span> 使用npm run命令来执行（npm run会将当前项目的./node_modules/.bin的绝对路径加入全局环境变量中）</span><br></pre></td></tr></tbody></table></figure><h4 id="PATH-环境变量"><a href="#PATH-环境变量" class="headerlink" title="PATH 环境变量"></a>PATH 环境变量</h4><p>在terminal中执行命令时，<strong>命令会在PATH环境变量里包含的路径中去寻找相同名字的可执行文件</strong>。局部安装的包只在./node_modules/.bin中注册了它们的可执行文件，不会被包含在PATH环境变量中，这个时候在terminal中输入命令将会报无法找到的错误。<br><strong>那为什么通过npm run可以执行局部安装的命令行包呢？</strong><br>​</p><p>npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。<br>比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。<br>我们来验证下这个说法。首先执行 cmd =&gt;path 查看当前所有的环境变量，可以看到PATH环境变量为：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1<span class="number">.0</span>\;C:\Windows\System32\OpenSSH\;D:\前端软件\Microsoft VS Code\bin;;D:\前端软件\Git\cmd;D:\前端软件\node\;C:\Users\ybchjia\AppData\Local\Microsoft\WindowsApps;C:\Users\ybchjia\AppData\Roaming\npm</span><br></pre></td></tr></tbody></table></figure><pre><code>再在当前项目下执行npm run env查看脚本运行时的环境变量，可以看到PATH环境变量为：</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path=D:\前端软件\node\node_modules\npm\node_modules\npm-lifecycle\node-gyp-bin;D:\project-demo\ip-tool\node_modules\.bin;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1<span class="number">.0</span>\;C:\Windows\System32\OpenSSH\;D:\前端软 </span><br><span class="line">件\Microsoft VS Code\bin;;D:\前端软件\Git\cmd;D:\前端软件\node\;C:\Users\ybchjia\AppData\Local\Microsoft\WindowsApps;C:\Users\ybchjia\AppData\Roaming\npm</span><br></pre></td></tr></tbody></table></figure><p>这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写mocha test就可以了。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"test"</span>: <span class="string">"mocha test"</span></span><br><span class="line"><span class="string">"test"</span>: <span class="string">"./node_modules/.bin/mocha test"</span> <span class="comment">// 不必带上路径</span></span><br></pre></td></tr></tbody></table></figure><p>由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。<br>npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。<br>​</p><p>PATH环境变量，是告诉系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到哪些目录下去寻找。<br>​</p><h3 id="用法指南"><a href="#用法指南" class="headerlink" title="用法指南"></a>用法指南</h3><h4 id="传入参数"><a href="#传入参数" class="headerlink" title="传入参数"></a>传入参数</h4><p>node处理scripts参数其实很简单，比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12582850/1629032201141-537a223f-f405-4a01-989f-fd10365bc906.png#clientId=ue2a260f2-efff-4&amp;from=paste&amp;height=132&amp;id=u6bc9ef8c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=150&amp;originWidth=631&amp;originalType=binary&amp;ratio=1&amp;size=24772&amp;status=done&amp;style=none&amp;taskId=u9e4d9430-50ea-428a-a084-4784028eb23&amp;width=553.4920349121094" alt="image.png"><br>除了第一个可执行的命令，以空格分割的任何字符串都是参数，并且都能通过process.argv属性访问。执行npm run serve3命令，process.argv的具体内容为：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12582850/1629032241556-ac230118-702b-4ca3-a0ea-f2e66fbaae7f.png#clientId=ue2a260f2-efff-4&amp;from=paste&amp;height=176&amp;id=u21b3f8d9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=200&amp;originWidth=631&amp;originalType=binary&amp;ratio=1&amp;size=29444&amp;status=done&amp;style=none&amp;taskId=u1dbb903d-9093-4da8-aa23-7cfc9594ad1&amp;width=554.4859008789062" alt="image.png"><br>很多命令行包之所以这么写，都是依赖了 minimist 或者  yargs ，coa等参数解析工具来对命令行参数进行解析。以minimist对vue-cli-service serve –mode=dev –mobile -config build/example.js解析为例，解析后的结果为：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12582850/1629032274531-2b333d35-2c45-47c5-aa23-9589eff91557.png#clientId=ue2a260f2-efff-4&amp;from=paste&amp;height=84&amp;id=u5742ba09&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=167&amp;originWidth=777&amp;originalType=binary&amp;ratio=1&amp;size=11794&amp;status=done&amp;style=none&amp;taskId=ub57736d4-bd43-4121-8ea8-3599438e970&amp;width=388.5" alt="image.png"><br>我们还可以通过命令行传参的形式来进行参数传递：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm run serve --params  <span class="comment">// 参数params将转化成process.env.npm_config_params = true</span></span><br><span class="line">npm run serve --params=<span class="number">123</span> <span class="comment">// 参数params将转化成process.env.npm_config_params = 123</span></span><br><span class="line">npm run serve -params  <span class="comment">// 等同于--params参数</span></span><br><span class="line"></span><br><span class="line">npm run serve -- --params  <span class="comment">// 将--params参数添加到process.argv数组中</span></span><br><span class="line">npm run serve params  <span class="comment">// 将params参数添加到process.argv数组中</span></span><br><span class="line">npm run serve -- params  <span class="comment">// 将params参数添加到process.argv数组中</span></span><br></pre></td></tr></tbody></table></figure><h4 id="多命令运行"><a href="#多命令运行" class="headerlink" title="多命令运行"></a>多命令运行</h4><h5 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h5><p>串行执行，要求前一个任务执行成功以后才能执行下一个任务，使用&amp;&amp;符号来连接。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run script1 &amp;&amp; npm run script2</span><br><span class="line">串行命令执行过程中，只要一个命令执行失败，则整个脚本终止。</span><br></pre></td></tr></tbody></table></figure><h5 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h5><p>并行执行，就是多个命令可以同时的平行执行，使用&amp;符号来连接。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run script1 &amp; npm run script2</span><br><span class="line"><span class="comment">// 这两个符号是Bash的内置功能。此外，还可以使用第三方的任务管理器模块：script-runner、npm-run-all、redrun。</span></span><br></pre></td></tr></tbody></table></figure><h2 id="4-实用技巧"><a href="#4-实用技巧" class="headerlink" title="4.实用技巧"></a>4.实用技巧</h2><h3 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">npm list/ls &lt;packageName&gt;</span><br><span class="line"><span class="comment">// 检查当前项目依赖的所有模块，包括子模块以及子模块的子模块;</span></span><br><span class="line">  </span><br><span class="line">npm view/info &lt;packageName&gt; version</span><br><span class="line"><span class="comment">// 模块已经发布的最新的版本信息（不包括预发布版本）</span></span><br><span class="line"></span><br><span class="line">npm view/info &lt;packageName&gt; versions </span><br><span class="line"><span class="comment">// 模块所有的历史版本信息（包括预发布版本）</span></span><br><span class="line"></span><br><span class="line">npm view/info &lt;packageName&gt; &lt;package.json中的key值&gt; </span><br><span class="line"> // 还能查看package.json中字段对应的值</span><br><span class="line">  </span><br><span class="line">npm view/info &lt;packageName&gt;</span><br><span class="line">// 查看某个模块的所有信息，包括它的依赖、关键字、更新日期、贡献者、仓库地址和许可证等：</span><br><span class="line">  </span><br><span class="line">npm outdated</span><br><span class="line">// 查看当前项目中可升级的模块：</span><br></pre></td></tr></tbody></table></figure><h3 id="查看模块文档"><a href="#查看模块文档" class="headerlink" title="查看模块文档"></a>查看模块文档</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打开模块的主页：npm home &lt;packageName&gt; </span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12582850/1629031781587-128c4c69-8fd0-46eb-aa47-9ac493bba51e.png#clientId=ue2a260f2-efff-4&amp;from=paste&amp;height=40&amp;id=ua9be24f4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=42&amp;originWidth=419&amp;originalType=binary&amp;ratio=1&amp;size=2988&amp;status=done&amp;style=none&amp;taskId=u1ba823a5-c6a0-4b2b-8e05-7d71ffa0f4b&amp;width=396.4918670654297" alt="image.png"></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打开模块的代码仓库：npm repo &lt;packageName&gt; </span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12582850/1629031812795-184e7b19-ebcd-419d-922d-eff34ed70de5.png#clientId=ue2a260f2-efff-4&amp;from=paste&amp;height=70&amp;id=ua720c18e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=98&amp;originWidth=569&amp;originalType=binary&amp;ratio=1&amp;size=6405&amp;status=done&amp;style=none&amp;taskId=ucfef75a1-157a-4f70-b349-a10fa3ffc20&amp;width=407.493896484375" alt="image.png"></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打开模块的 issues 地址：npm bugs &lt;packageName&gt;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12582850/1629031842936-4c11d87c-7132-4d06-b237-be77ee85ac9d.png#clientId=ue2a260f2-efff-4&amp;from=paste&amp;height=61&amp;id=ua2b9f783&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=77&amp;originWidth=543&amp;originalType=binary&amp;ratio=1&amp;size=4683&amp;status=done&amp;style=none&amp;taskId=u21710b30-ef8a-4bba-b6f3-50cacfb4dcf&amp;width=428.49822998046875" alt="image.png"></p><h3 id="本地开发模块调试"><a href="#本地开发模块调试" class="headerlink" title="本地开发模块调试"></a>本地开发模块调试</h3><p>方案一：本地打包引用     </p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本地包：npm pack</span><br><span class="line">项目：npm i &lt; package &gt;（本地路径）</span><br></pre></td></tr></tbody></table></figure><p>方案二：npm发布引用</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i  &lt; packageName &gt;</span><br></pre></td></tr></tbody></table></figure><p>方案三：npm link（重点）    本地包：npm link这会创建一个软连接，并保存到目录<br>C:\Users\Administrator\AppData\Roaming\npm\node_modules 下面</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link &lt; packageName &gt;</span><br></pre></td></tr></tbody></table></figure><p>这就将这个公共的项目通过软连接的方式引入到项目里面来了;<br>这时修改common项目下面的任意代码都会实时生效，不用打包，不用更新引入包，也不用重启。需要注意的是，当项目包依赖更新后，也就是执行了 npm install xxx 之后，需要重新link项目。</p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> node </tag>
            
            <tag> dependencies </tag>
            
            <tag> script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/02/hello-world/"/>
      <url>/2021/11/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在浏览器输入 URL 到页面加载发生了什么？</title>
      <link href="/2021/11/01/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2021/11/01/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p><code>过程综述：</code></p><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h2 id="一-DNS-解析"><a href="#一-DNS-解析" class="headerlink" title="一. DNS 解析"></a>一. DNS 解析</h2><ol><li><p><code>wiki</code>介绍:</p><blockquote><p>域名系统（domain name system，缩写：DNS）是互联网的一项服务。它作为将域名和 ip 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。DNS 使用 TCP 和 UDP 端口 53.当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能朝服哦 253 个字符。<font color="red">最基本的作用就是将域名翻译成对应的 IP 地址</font></p></blockquote></li><li><p>域名解析过程</p><ul><li><p>检查缓存</p><ol><li>浏览器缓存<blockquote><p>用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对用的 ip 地址（若曾经访问过，没有被清除，就会存在）</p></blockquote></li><li>系统缓存<blockquote><p>检查系统的 hosts 文件有没有这个域名的映射，如果有，直接返回</p></blockquote></li></ol></li><li><p>ISP（互联网服务提供商）DNS 缓存</p><blockquote><p>如果 hosts 与本地的 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器，在此我们叫它 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p></blockquote></li><li><p>根域名服务器</p><blockquote><p>当以上均未完成，则进入根服务器查询，全球仅有 13 台服务器，1 个根域名服务器，其余 12 台为辅助域名服务器。根域名收到请求后会查询域名文件记录，若无则将其管辖的顶级域名（如： .com）服务器 IP 告诉本地 DNS 服务器</p></blockquote></li><li><p>顶级域名服务器</p><blockquote><p>顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器 IP 地址告诉本地服务器</p></blockquote></li><li><p>主域名服务器</p><blockquote><p>主域名服务器接收到请求以后查询自己的缓存，如果没有则进入下一级域名服务器查找，并重复该步骤直至找到正确记录</p></blockquote></li><li><p>保存结果到缓存</p><blockquote><p>本地域名服务器吧返回的结果保存到缓存</p></blockquote></li></ul></li></ol><p><img src="/chintdev.github.io/images/dns.jpg" alt="DNS"></p><h2 id="二-TCP-链接"><a href="#二-TCP-链接" class="headerlink" title="二. TCP 链接"></a>二. TCP 链接</h2><ol><li><p>第一次握手：CLient 将标识位 SYN 置为 1，随机产生一个值 seq=j，并将该数据包发送至 Server，Client 进入 SYN_SEND 状态，等待 Server 确认。</p></li><li><p>第二次握手：Server 收到数据包后由标志位 SYN=1 知道 Client 请求建立链接，Server 将标识位 SYN 和 ACK 都置为 1，ACK=j+1，随机产生一个值 seq=K，并将该数据包发送给 Client 以确认连接请求。</p></li><li><p>第三次握手：Client 收到确认后，检查 ACK 是否为 j+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ACK=k+1,并将该数据发送给 Server，Server 检查 ACK 是否为 k+1,ACK 是否为 1，如果正确则建立连接成功，Client 和 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。</p></li></ol><h3 id="三-HTTP-请求"><a href="#三-HTTP-请求" class="headerlink" title="三. HTTP 请求"></a>三. HTTP 请求</h3><blockquote><p>发送 HTTP 请求的过程就是构建 HTTP 请求报文并通过 TCP 协议中发送服务器指定端口（HTTP 协议 80/8080，HTTPS 协议 443）.<br>HTTP 请求报文由三部分组成： 请求头，请求行，请求体</p></blockquote><h4 id="四-服务器处理请求返回-HTTP-报文"><a href="#四-服务器处理请求返回-HTTP-报文" class="headerlink" title="四. 服务器处理请求返回 HTTP 报文"></a>四. 服务器处理请求返回 HTTP 报文</h4><blockquote><p>后端从在固定的端口接收到 TCP 报文开始，这一部分对于编程语言中的 socket。他会对 TCP 连接进行处理，对 HTTP 协议进行解析，并按照报文格式进一步封装成 HTTP Request 对象，供上层使用。<br>HTTP 响应报文包括三部分：状态码，响应报头，响应报文</p></blockquote><h5 id="五-浏览器解析渲染页面"><a href="#五-浏览器解析渲染页面" class="headerlink" title="五. 浏览器解析渲染页面"></a>五. 浏览器解析渲染页面</h5><blockquote><p>浏览器是一个边间谍西边渲染的过程。首先浏览器解析 HTML 文件构成 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂。</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> HTTP </tag>
            
            <tag> TCP </tag>
            
            <tag> URL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
